use crate::value::Value;
use crate::ast::{Expr, Stmt};
use mathcore::MathCore;
use std::collections::HashMap;

// 全局CAS存储
use std::sync::Mutex;

lazy_static::lazy_static! {
    static ref CAS_STORAGE: Mutex<HashMap<String, String>> = Mutex::new(HashMap::new());
}

// Helper function to convert Value to expression string
fn value_to_expr_string(value: &Value) -> Result<String, String> {
    match value {
        Value::String(s) => Ok(s.clone()),
        Value::Lambda { params, body, .. } | Value::Function { params, body, .. } => {
            // For lambda/function, we need to convert the body to an expression string
            // This is a simplified conversion that handles common cases
            if params.len() != 1 {
                return Err("Function must have exactly one parameter for calculus operations".to_string());
            }
            
            // Convert the body statement to an expression string
            // This is a simplified implementation - in practice, you'd need full AST-to-string conversion
            stmt_to_expr_string(body, &params[0])
        }
        _ => Err(format!("Cannot convert {} to expression string", value.type_name())),
    }
}

// Helper function to convert Stmt to expression string
fn stmt_to_expr_string(stmt: &Stmt, var: &str) -> Result<String, String> {
    match stmt {
        Stmt::Expr(expr) => expr_to_string(expr, var),
        Stmt::Return(expr) => expr_to_string(expr, var),
        _ => Err("Unsupported statement type for expression conversion".to_string()),
    }
}

// Helper function to convert Expr to string
fn expr_to_string(expr: &Expr, var: &str) -> Result<String, String> {
    match expr {
        Expr::Int(n) => Ok(n.to_string()),
        Expr::Float(f) => Ok(f.to_string()),
        Expr::Ident(name) => {
            if name == var {
                Ok(var.to_string())
            } else {
                Ok(name.to_string())
            }
        }
        Expr::Binary { left, op, right } => {
            let left_str = expr_to_string(left, var)?;
            let right_str = expr_to_string(right, var)?;
            let op_str = match op {
                crate::ast::BinOp::Add => "+",
                crate::ast::BinOp::Sub => "-",
                crate::ast::BinOp::Mul => "*",
                crate::ast::BinOp::Div => "/",
                crate::ast::BinOp::Pow => "^",
                crate::ast::BinOp::Mod => "%",
                _ => return Err(format!("Unsupported binary operator: {:?}", op)),
            };
            Ok(format!("({} {} {})", left_str, op_str, right_str))
        }
        Expr::Unary { op, expr: inner } => {
            let inner_str = expr_to_string(inner, var)?;
            match op {
                crate::ast::UnaryOp::Neg => Ok(format!("(-{})", inner_str)),
                _ => Err(format!("Unsupported unary operator: {:?}", op)),
            }
        }
        Expr::Call { func, args } => {
            if let Expr::Ident(func_name) = func.as_ref() {
                let arg_strs: Result<Vec<_>, _> = args.iter()
                    .map(|arg| expr_to_string(arg, var))
                    .collect();
                let arg_strs = arg_strs?;
                Ok(format!("{}({})", func_name, arg_strs.join(", ")))
            } else {
                Err("Complex function calls not supported in expression conversion".to_string())
            }
        }
        _ => Err(format!("Unsupported expression type: {:?}", expr)),
    }
}

// CAS内置函数接口
pub fn parse(args: &[Value]) -> Result<Value, String> {
    if args.len() != 1 {
        return Err("cas_parse expects 1 argument".to_string());
    }

    match &args[0] {
        Value::String(s) => {
            // 解析表达式
            match MathCore::parse(s) {
                Ok(expr) => Ok(Value::String(format!("{:?}", expr))),
                Err(e) => Err(format!("Parse error: {}", e)),
            }
        }
        _ => Err("cas_parse expects string".to_string()),
    }
}

// CAS内置函数接口
pub fn parse(args: &[Value]) -> Result<Value, String> {
    if args.len() != 1 {
        return Err("parse expects 1 argument".to_string());
    }

    match &args[0] {
        Value::String(s) => {
            // 解析表达式
            match MathCore::parse(s) {
                Ok(expr) => Ok(Value::String(format!("{:?}", expr))),
                Err(e) => Err(format!("Parse error: {}", e)),
            }
        }
        _ => Err("parse expects string".to_string()),
    }
}

pub fn differentiate(args: &[Value]) -> Result<Value, String> {
    if args.len() != 2 {
        return Err("differentiate expects 2 arguments (expr, var)".to_string());
    }

    let expr_str = value_to_expr_string(&args[0])?;

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("differentiate expects string variable as second argument".to_string());
    };

    // 求导
    match MathCore::differentiate(&expr_str, &var) {
        Ok(derivative) => Ok(Value::String(format!("{}", derivative))),
        Err(e) => Err(format!("Differentiation error: {}", e)),
    }
}

pub fn solve_linear(args: &[Value]) -> Result<Value, String> {
    if args.len() != 2 {
        return Err("cas_solve_linear expects 2 arguments (expr, var)".to_string());
    }

    let expr_str = if let Value::String(s) = &args[0] {
        s.clone()
    } else {
        return Err("cas_solve_linear expects string expression".to_string());
    };

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("cas_solve_linear expects string variable".to_string());
    };

    // 求解方程
    match MathCore::solve(&expr_str, &var) {
        Ok(roots) => {
            // 返回第一个根（对于线性方程通常只有一个根）
            if !roots.is_empty() {
                if let mathcore::Expr::Number(n) = &roots[0] {
                    Ok(Value::Float(*n))
                } else {
                    Err("Solution is not a number".to_string())
                }
            } else {
                Err("Cannot solve equation".to_string())
            }
        }
        Err(e) => Err(format!("Solve error: {}", e)),
    }
}

pub fn cas_evaluate_at(args: &[Value]) -> Result<Value, String> {
    if args.len() != 3 {
        return Err("cas_evaluate_at expects 3 arguments (expr, var, value)".to_string());
    }

    let expr_str = if let Value::String(s) = &args[0] {
        s.clone()
    } else {
        return Err("cas_evaluate_at expects string expression".to_string());
    };

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("cas_evaluate_at expects string variable".to_string());
    };

    let value = args[2].to_float()?;

    // 解析并求值
    let math = MathCore::new();
    let mut vars = std::collections::HashMap::new();
    vars.insert(var, value);

    match math.evaluate_with_vars(&expr_str, &vars) {
        Ok(result) => Ok(Value::Float(result)),
        Err(e) => Err(format!("Evaluation error: {}", e)),
    }
}

pub fn cas_store(args: &[Value]) -> Result<Value, String> {
    if args.len() != 2 {
        return Err("cas_store expects 2 arguments (name, expr)".to_string());
    }

    let name = if let Value::String(n) = &args[0] {
        n.clone()
    } else {
        return Err("cas_store expects string name".to_string());
    };

    let expr = if let Value::String(s) = &args[1] {
        s.clone()
    } else {
        return Err("cas_store expects string expression".to_string());
    };

    // 验证表达式是否可以解析
    MathCore::parse(&expr).map_err(|e| format!("Invalid expression: {}", e))?;

    CAS_STORAGE.lock().unwrap().insert(name, expr);
    Ok(Value::Null)
}

pub fn cas_load(args: &[Value]) -> Result<Value, String> {
    if args.len() != 1 {
        return Err("cas_load expects 1 argument (name)".to_string());
    }

    let name = if let Value::String(n) = &args[0] {
        n.clone()
    } else {
        return Err("cas_load expects string name".to_string());
    };

    if let Some(expr) = CAS_STORAGE.lock().unwrap().get(&name) {
        Ok(Value::String(expr.clone()))
    } else {
        Err(format!("Expression '{}' not found in storage", name))
    }
}

pub fn cas_numerical_derivative(args: &[Value]) -> Result<Value, String> {
    if args.len() != 3 {
        return Err("cas_numerical_derivative expects 3 arguments (expr, var, point)".to_string());
    }

    let expr_str = if let Value::String(s) = &args[0] {
        s.clone()
    } else {
        return Err("cas_numerical_derivative expects string expression".to_string());
    };

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("cas_numerical_derivative expects string variable".to_string());
    };

    let point = args[2].to_float()?;

    let math = MathCore::new();
    let h = 1e-8;

    let mut vars_plus = std::collections::HashMap::new();
    vars_plus.insert(var.clone(), point + h);

    let mut vars_minus = std::collections::HashMap::new();
    vars_minus.insert(var.clone(), point - h);

    let f_plus = math
        .evaluate_with_vars(&expr_str, &vars_plus)
        .map_err(|e| format!("Evaluation error: {}", e))?;
    let f_minus = math
        .evaluate_with_vars(&expr_str, &vars_minus)
        .map_err(|e| format!("Evaluation error: {}", e))?;

    let derivative = (f_plus - f_minus) / (2.0 * h);

    Ok(Value::Float(derivative))
}

pub fn cas_integrate(args: &[Value]) -> Result<Value, String> {
    if args.len() != 2 {
        return Err("cas_integrate expects 2 arguments (expr, var)".to_string());
    }

    let expr_str = if let Value::String(s) = &args[0] {
        s.clone()
    } else {
        return Err("cas_integrate expects string expression".to_string());
    };

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("cas_integrate expects string variable".to_string());
    };

    // 积分
    match MathCore::integrate(&expr_str, &var) {
        Ok(integral) => Ok(Value::String(format!("{}", integral))),
        Err(e) => Err(format!("Integration error: {}", e)),
    }
}

pub fn cas_definite_integral(args: &[Value]) -> Result<Value, String> {
    if args.len() != 4 {
        return Err(
            "cas_definite_integral expects 4 arguments (expr, var, lower, upper)".to_string(),
        );
    }

    let expr_str = if let Value::String(s) = &args[0] {
        s.clone()
    } else {
        return Err("cas_definite_integral expects string expression".to_string());
    };

    let var = if let Value::String(v) = &args[1] {
        v.clone()
    } else {
        return Err("cas_definite_integral expects string variable".to_string());
    };

    let lower = args[2].to_float()?;
    let upper = args[3].to_float()?;

    // 数值积分
    match MathCore::numerical_integrate(&expr_str, &var, lower, upper) {
        Ok(result) => Ok(Value::Float(result)),
        Err(e) => Err(format!("Integration error: {}", e)),
    }
}
